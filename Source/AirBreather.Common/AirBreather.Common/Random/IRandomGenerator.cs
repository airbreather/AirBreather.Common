using System;

namespace AirBreather.Common.Random
{
    public enum RandomnessKind
    {
        PseudoRandom,
        Random
    }

    // ...but then again, sometimes randomness itself IS needed (e.g., in implementing IPicker).
    // The complexity here is why I hesitated for so long to add this, in favor of IPicker.
    public interface IRandomGenerator<TState> where TState: struct, IRandomGeneratorState
    {
        /// <summary>
        /// Gets the size of each "chunk" of bytes that can be generated at a time.
        /// This value must remain constant throughout the lifetime of an instance.
        /// </summary>
        /// <remarks>
        /// Implementations of <see cref="FillBuffer"/> may reject count values that are not
        /// multiples of this value.
        /// </remarks>
        int ChunkSize { get; }

        /// <summary>
        /// Gets a <see cref="RandomnessKind"/> value indicating what kind of randomn data is
        /// generated by this generator.
        /// </summary>
        RandomnessKind RandomnessKind { get; }

        /// <summary>
        /// Fills the specified range of the specified buffer with random or pseudorandom data.
        /// </summary>
        /// <param name="state">
        /// The <typeparamref name="TState"/> value that encapsulates the state of the generator.
        /// See remarks for expectations and guarantees.
        /// </param>
        /// <param name="buffer">
        /// A buffer that this method should populate with random bytes.
        /// </param>
        /// <param name="index">
        /// The index of <paramref name="buffer"/> at which to start populating random data.
        /// </param>
        /// <param name="count">
        /// The number of bytes in <paramref name="buffer"/>, starting at <paramref name="index"/>,
        /// to populate with random data.
        /// </param>
        /// <returns>
        /// A <typeparamref name="TState"/> value to use for subsequent calls, if needed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="buffer"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> or <paramref name="count"/> is negative.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index"/> plus <paramref name="count"/> is greater than or equal to the
        /// length of <paramref name="buffer"/>, <paramref name="state"/> is not
        /// <see cref="IRandomGeneratorState.IsValid">valid</see>, or <paramref name="index"/> is
        /// not a multiple of <see cref="ChunkSize"/>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// If <see cref="RandomnessKind"/> is <see cref="Random.RandomnessKind.Random"/>, results
        /// may not be repeatable (no guarantees are made about the input or output state).
        /// </para>
        /// <para>
        /// If <see cref="RandomnessKind"/> is <see cref="Random.RandomnessKind.PseudoRandom"/>,
        /// results for equal <paramref name="state"/> values will always generate the same sequence
        /// of random bytes, and the return value after generating a given number of bytes will
        /// always be the same, no matter how many calls it took to generate that.  For example,
        /// generating 16 bytes, then passing the resulting state into another call that generates 8
        /// bytes will return the same state as requesting 24 bytes at once for the original state.
        /// </para>
        /// <para>
        /// Data in <paramref name="buffer"/> outside of the range given by <paramref name="index"/>
        /// and <paramref name="count"/> will not be modified by this method.
        /// </para>
        /// <para>
        /// Implementations are not <b>required</b> to throw <see cref="ArgumentException"/> when
        /// <paramref name="state"/> is not <see cref="IRandomGeneratorState.IsValid">valid</see>.
        /// </para>
        /// </remarks>
        TState FillBuffer(TState state, byte[] buffer, int index, int count);
    }
}
