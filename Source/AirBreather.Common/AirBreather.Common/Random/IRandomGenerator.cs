using System;

namespace AirBreather.Common.Random
{
    /// <summary>
    /// A value indicating what "kind" of randomness is being generated.  Currently a glorified
    /// <see cref="Boolean"/> that indicates whether this is pseudo-random (i.e., deterministic but
    /// statistically unpredictable), or truly random (i.e., statistically unpredictable, non-
    /// deterministic, and unrepeatable).
    /// </summary>
    public enum RandomnessKind
    {
        PseudoRandom,
        Random
    }

    /// <summary>
    /// A generator of random data.  Rather than maintaining its own state, the state is maintained
    /// outside of the generators.  This allows a single generator to be used from multiple threads
    /// at once, and it gives callers more freedom for how to .
    /// </summary>
    /// <typeparam name="TState">
    /// The type of <see cref="IRandomGeneratorState"/> that stores the state.
    /// </typeparam>
    public interface IRandomGenerator<TState> where TState: struct, IRandomGeneratorState
    {
        /// <summary>
        /// Gets the size of each "chunk" of bytes that can be generated at a time.
        /// This value must remain constant throughout the lifetime of an instance.
        /// </summary>
        /// <remarks>
        /// Implementations of <see cref="FillBuffer"/> may reject count values that are not
        /// multiples of this value.
        /// </remarks>
        int ChunkSize { get; }

        /// <summary>
        /// Gets a <see cref="Random.RandomnessKind"/> value indicating what kind of random data is
        /// generated by this generator.
        /// </summary>
        RandomnessKind RandomnessKind { get; }

        /// <summary>
        /// Fills the specified range of the specified buffer with random or pseudorandom data.
        /// </summary>
        /// <param name="state">
        /// The <typeparamref name="TState"/> value that encapsulates the state of the generator.
        /// See remarks for expectations and guarantees.
        /// </param>
        /// <param name="buffer">
        /// A buffer that this method should populate with random bytes.
        /// </param>
        /// <param name="index">
        /// The index of <paramref name="buffer"/> at which to start populating random data.
        /// </param>
        /// <param name="count">
        /// The number of bytes in <paramref name="buffer"/>, starting at <paramref name="index"/>,
        /// to populate with random data.
        /// </param>
        /// <returns>
        /// A <typeparamref name="TState"/> value to use for subsequent calls, if needed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="buffer"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> or <paramref name="count"/> is negative.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index"/> plus <paramref name="count"/> is greater than or equal to the
        /// length of <paramref name="buffer"/>, <paramref name="state"/> is not
        /// <see cref="IRandomGeneratorState.IsValid">valid</see>, or <paramref name="index"/> is
        /// not a multiple of <see cref="ChunkSize"/>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// If <see cref="RandomnessKind"/> is <see cref="Random.RandomnessKind.Random"/>, results
        /// may not be repeatable (no guarantees are made about the input or output state).
        /// </para>
        /// <para>
        /// If <see cref="RandomnessKind"/> is <see cref="Random.RandomnessKind.PseudoRandom"/>,
        /// results for equal <paramref name="state"/> values will always generate the same sequence
        /// of random bytes, and the return value after generating a given number of bytes will
        /// always be the same, no matter how many calls it took to generate that.  For example,
        /// generating 16 bytes, then passing the resulting state into another call that generates 8
        /// bytes will return the same state as requesting 24 bytes at once for the original state.
        /// </para>
        /// <para>
        /// Data in <paramref name="buffer"/> outside of the range given by <paramref name="index"/>
        /// and <paramref name="count"/> will not be modified by this method.
        /// </para>
        /// <para>
        /// Implementations are not <b>required</b> to throw <see cref="ArgumentException"/> when
        /// <paramref name="state"/> is not <see cref="IRandomGeneratorState.IsValid">valid</see>,
        /// but callers should still avoid calling this with such a state.
        /// </para>
        /// </remarks>
        TState FillBuffer(TState state, byte[] buffer, int index, int count);
    }
}
